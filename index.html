<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Trajectory Visualizer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #0f172a;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- Floating Window Styles --- */
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(30, 41, 59, 0.95);
            border-radius: 8px; /* Slightly sharper corners for window look */
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.5);
            width: 300px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            user-select: none;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            
            /* Resizable properties */
            resize: horizontal; 
            overflow: hidden; /* Required for resize handle to show */
            min-width: 250px;
            max-width: 600px;
            
            /* Ensure it catches clicks */
            pointer-events: auto;
        }

        /* Drag Handle Header */
        #panel-header {
            padding: 10px 15px;
            background: rgba(15, 23, 42, 0.8);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            cursor: move; /* Indicates draggable */
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #panel-header h2 {
            margin: 0;
            font-size: 1rem;
            color: #38bdf8;
            pointer-events: none; /* Let clicks pass to header for dragging */
        }

        #minimize-btn {
            background: none;
            border: none;
            color: #94a3b8;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0 5px;
            line-height: 1;
        }
        #minimize-btn:hover { color: white; background: none; }

        /* Content Area */
        #panel-content {
            padding: 15px;
            overflow-y: auto; /* Handle internal content scrolling if resized too small */
        }

        /* Minimized State */
        #controls.minimized {
            resize: none; /* Lock size when minimized */
            height: auto !important; /* Force auto height */
            width: 300px !important; /* Reset width */
        }

        #controls.minimized #panel-content > :not(.essential-only) {
            display: none;
        }
        
        #controls.minimized .essential-elements-wrapper {
             /* Wrapper specific logic if needed */
        }

        /* Essential Elements (Slider) Styling updates for minimized view */
        .slider-wrapper { margin-bottom: 0; }
        
        /* Hiding specific parts of the slider container in minimized mode */
        #controls.minimized .slider-labels,
        #controls.minimized .btn-group,
        #controls.minimized .zoom-hint {
            display: none;
        }
        
        #controls.minimized .slider-container {
            margin-bottom: 0;
        }

        /* --- Existing UI Styles --- */
        .slider-container { margin-bottom: 20px; }
        
        label { display: block; margin-bottom: 8px; font-weight: bold; font-size: 0.9rem; }
        
        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #475569;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            cursor: pointer;
            position: relative;
            z-index: 1001;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            background: #38bdf8;
            border-radius: 50%;
            cursor: pointer;
            transition: background .15s ease-in-out;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
            margin-top: -2px;
        }

        input[type="range"]::-webkit-slider-thumb:hover { background: #0ea5e9; }

        .stats {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .stat-row { display: flex; justify-content: space-between; }
        .stat-val { font-family: monospace; color: #cbd5e1; }

        .legend { margin-top: 10px; font-size: 0.8rem; color: #94a3b8; }
        .legend span { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 5px; }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            cursor: grab;
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1; 
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        .classification {
            font-weight: bold;
            color: #fbbf24;
            margin-bottom: 5px;
            display: block;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        button.action-btn {
            background: #334155;
            border: 1px solid #475569;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            flex: 1;
        }
        button.action-btn:hover { background: #475569; }

        .zoom-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            z-index: 1000;
        }
        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
        }
        
        .slider-labels {
            display: flex; 
            justify-content: space-between; 
            font-size: 0.7rem; 
            color: #94a3b8; 
            margin-top: 5px;
        }

    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
    </div>

    <div id="controls">
        <div id="panel-header">
            <h2>Orbital Control</h2>
            <button id="minimize-btn" title="Minimize">−</button>
        </div>
        
        <div id="panel-content">
            <!-- Added 'essential-only' class to wrapper to keep it visible during minimize -->
            <div class="slider-container essential-only">
                <label for="velocitySlider">Velocity (v): <span id="vDisplay">1.00</span> v<sub>orb</sub></label>
                <input type="range" id="velocitySlider" min="0.5" max="2.0" step="0.001" value="1.0">
                
                <div class="slider-labels">
                    <span>Fall</span>
                    <span>Circ (1.0)</span>
                    <span>Esc (1.41)</span>
                    <span>Fast</span>
                </div>
                <div class="btn-group">
                    <button class="action-btn" onclick="setSpeed(1.0)">Set Circular</button>
                    <button class="action-btn" onclick="setSpeed(1.414)">Set Escape</button>
                </div>
            </div>

            <div class="stats">
                <span id="orbitType" class="classification">Circular Orbit</span>
                <div class="stat-row">
                    <span>Eccentricity (e):</span>
                    <span id="eccentricityDisplay" class="stat-val">0.00</span>
                </div>
            </div>

            <div class="legend">
                <div><span style="border: 1px dashed #38bdf8; width: 15px; height: 0px; display: inline-block; vertical-align: middle;"></span> Reference Circular Orbit</div>
                <div><span style="background: #fbbf24; width: 15px; height: 2px; display: inline-block; vertical-align: middle;"></span> Current Trajectory</div>
                <div><span style="background: white; border-radius: 50%;"></span> Central Mass</div>
                <div><span style="background: #4ade80; border-radius: 50%;"></span> Injection Point</div>
            </div>
            
            <div class="zoom-hint" style="margin-top: 15px; font-size: 0.8rem; color: #64748b; font-style: italic;">
                * Scroll to Zoom, Drag to Move Map
            </div>
        </div>
    </div>

    <div class="zoom-controls">
        <button class="zoom-btn" onclick="adjustZoom(0.9)">−</button>
        <button class="zoom-btn" onclick="adjustZoom(1.1)">+</button>
    </div>

<script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('canvas-container');
    const slider = document.getElementById('velocitySlider');
    const vDisplay = document.getElementById('vDisplay');
    const orbitTypeDisplay = document.getElementById('orbitType');
    const eDisplay = document.getElementById('eccentricityDisplay');
    
    // Panel Elements
    const controls = document.getElementById('controls');
    const header = document.getElementById('panel-header');
    const minimizeBtn = document.getElementById('minimize-btn');

    let view = {
        scale: 1,
        offsetX: 0,
        offsetY: 0,
        isDragging: false,
        lastX: 0,
        lastY: 0
    };

    // --- Panel Logic (Drag & Minimize) ---

    // Minimize Toggle
    minimizeBtn.addEventListener('click', () => {
        controls.classList.toggle('minimized');
        if (controls.classList.contains('minimized')) {
            minimizeBtn.textContent = '+';
        } else {
            minimizeBtn.textContent = '−';
        }
    });

    // Panel Dragging
    let isPanelDragging = false;
    let panelStartX, panelStartY, panelStartLeft, panelStartTop;

    header.addEventListener('mousedown', (e) => {
        // Don't drag if clicking the minimize button
        if(e.target === minimizeBtn) return;
        
        isPanelDragging = true;
        panelStartX = e.clientX;
        panelStartY = e.clientY;
        
        // Get current computed position
        const rect = controls.getBoundingClientRect();
        panelStartLeft = rect.left;
        panelStartTop = rect.top;
        
        // Remove bottom/right positioning if any, switch to top/left only
        controls.style.bottom = 'auto';
        controls.style.right = 'auto';
        controls.style.width = rect.width + 'px'; // Freeze width during drag
    });

    window.addEventListener('mousemove', (e) => {
        if (isPanelDragging) {
            const dx = e.clientX - panelStartX;
            const dy = e.clientY - panelStartY;
            controls.style.left = (panelStartLeft + dx) + 'px';
            controls.style.top = (panelStartTop + dy) + 'px';
        }
    });

    window.addEventListener('mouseup', () => {
        isPanelDragging = false;
    });


    // --- Existing Simulation Logic ---

    const GM = 1; 
    const R_START = 150;

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        draw();
    }
    window.addEventListener('resize', resize);

    function setSpeed(val) {
        slider.value = val;
        draw();
    }

    function adjustZoom(factor) {
        view.scale *= factor;
        draw();
    }

    // Canvas Interaction
    container.addEventListener('mousedown', e => {
        if (e.target.tagName !== 'CANVAS') return;
        view.isDragging = true;
        view.lastX = e.clientX;
        view.lastY = e.clientY;
    });

    window.addEventListener('mouseup', () => view.isDragging = false);
    
    window.addEventListener('mousemove', e => {
        if (!view.isDragging) return;
        view.offsetX += e.clientX - view.lastX;
        view.offsetY += e.clientY - view.lastY;
        view.lastX = e.clientX;
        view.lastY = e.clientY;
        draw();
    });

    container.addEventListener('touchstart', e => {
        if (e.target.tagName !== 'CANVAS') return;
        view.isDragging = true;
        view.lastX = e.touches[0].clientX;
        view.lastY = e.touches[0].clientY;
    }, {passive: false});

    window.addEventListener('touchend', () => view.isDragging = false);

    window.addEventListener('touchmove', e => {
        if (!view.isDragging) return;
        e.preventDefault();
        const x = e.touches[0].clientX;
        const y = e.touches[0].clientY;
        view.offsetX += x - view.lastX;
        view.offsetY += y - view.lastY;
        view.lastX = x;
        view.lastY = y;
        draw();
    }, {passive: false});

    window.addEventListener('wheel', e => {
        e.preventDefault();
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        view.scale *= factor;
        draw();
    }, { passive: false });


    function draw() {
        try {
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const cx = canvas.width / 2 + view.offsetX;
            const cy = canvas.height / 2 + view.offsetY;
            const R_VISUAL = R_START * view.scale;

            let vRatio = parseFloat(slider.value);
            
            if (Math.abs(vRatio - Math.sqrt(2)) < 0.02) vRatio = Math.sqrt(2);
            if (Math.abs(vRatio - 1.0) < 0.015) vRatio = 1.0;

            const E = (vRatio * vRatio) / 2 - 1;
            const h = vRatio;
            let e = Math.sqrt(1 + 2 * E * h * h);
            
            if (vRatio === Math.sqrt(2)) e = 1.0;
            if (vRatio === 1.0) e = 0.0;

            const p = h * h;
            
            vDisplay.textContent = vRatio.toFixed(3);
            eDisplay.textContent = e.toFixed(3);

            let orbitColor = "#fbbf24";
            
            if (vRatio < 0.999) {
                orbitTypeDisplay.textContent = "Elliptical (Launch = Apoapsis)";
                orbitTypeDisplay.style.color = "#fbbf24";
            } else if (vRatio >= 0.999 && vRatio <= 1.001) {
                orbitTypeDisplay.textContent = "Circular";
                orbitTypeDisplay.style.color = "#4ade80";
            } else if (vRatio > 1.001 && e < 0.999) {
                orbitTypeDisplay.textContent = "Elliptical (Launch = Periapsis)";
                orbitTypeDisplay.style.color = "#fbbf24";
            } else if (e >= 0.999 && e <= 1.001) {
                orbitTypeDisplay.textContent = "Parabolic (Escape)";
                orbitTypeDisplay.style.color = "#f472b6"; 
                orbitColor = "#f472b6";
            } else {
                orbitTypeDisplay.textContent = "Hyperbolic (Escape)";
                orbitColor = "#f87171"; 
                orbitTypeDisplay.style.color = "#f87171";
            }

            ctx.beginPath();
            ctx.arc(cx, cy, 5 * view.scale, 0, Math.PI * 2); 
            ctx.fillStyle = 'white';
            ctx.fill();

            ctx.beginPath();
            ctx.arc(cx, cy, R_VISUAL, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(56, 189, 248, 0.4)'; 
            ctx.lineWidth = 2; 
            ctx.setLineDash([8 * view.scale, 8 * view.scale]); 
            ctx.stroke();
            ctx.setLineDash([]); 

            ctx.beginPath();
            ctx.strokeStyle = orbitColor;
            ctx.lineWidth = 3;

            let step = 0.02;
            let startAngle = 0;
            let endAngle = Math.PI * 2;
            
            if (e >= 1.0) {
                let limitAngle;
                if (e === 1.0) limitAngle = Math.PI - 0.1; 
                else limitAngle = Math.acos(-1/e) - 0.05; 
                
                startAngle = -limitAngle;
                endAngle = limitAngle;
                step = 0.01; 
            }

            let firstPoint = true;

            for (let theta = startAngle; theta <= endAngle; theta += step) {
                const r_norm = p / (1 + e * Math.cos(theta));
                
                if (r_norm < 0) continue; 
                
                const r_pixels = r_norm * R_VISUAL; 
                
                if (r_pixels > 1000000) continue;

                let x = r_pixels * Math.cos(theta);
                let y = r_pixels * Math.sin(theta);
                
                let rotX, rotY;
                if (vRatio >= 1) {
                     rotX = x * Math.cos(-Math.PI/2) - y * Math.sin(-Math.PI/2);
                     rotY = x * Math.sin(-Math.PI/2) + y * Math.cos(-Math.PI/2);
                } else {
                     rotX = x * Math.cos(Math.PI/2) - y * Math.sin(Math.PI/2);
                     rotY = x * Math.sin(Math.PI/2) + y * Math.cos(Math.PI/2);
                }

                if (firstPoint) {
                    ctx.moveTo(cx + rotX, cy + rotY);
                    firstPoint = false;
                } else {
                    ctx.lineTo(cx + rotX, cy + rotY);
                }
            }
            
            if (e < 1.0) {
                ctx.closePath();
            }
            
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(cx, cy - R_VISUAL, 6 * view.scale, 0, Math.PI * 2);
            ctx.fillStyle = '#4ade80';
            ctx.fill();
        } catch (err) {
            console.error("Drawing error:", err);
        }
    }

    slider.addEventListener('input', draw);
    resize();

</script>
</body>
</html>
